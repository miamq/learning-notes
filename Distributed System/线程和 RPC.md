# 线程和 RPC
*作者: Eason* <br>
*时间: 2022/03/26*

<br>

## 编程语言 Go
本系列课程使用的编程语言为一律为 ```Go```, 使用其的原因如下:
- 对线程 (threads) 有着很好的支持
- 提供便捷的 RPC (什么是 RPC 本节末会进行讲解)
- 对比 C/C++, 有垃圾回收 (Garbage Collection) 机制, 大大简化多线程编程
- 语法通俗，容易上手

学习 Go 的[官方教程](https://go.dev/tour/list)。该教程小巧精致，有其他语言基础者一两天时间就能将 Go 掌握个差不多了

## 线程
### 线程的概述
当计算机执行某个 ```程序 (Program)``` 时，计算机首先创建的是一个 ```进程 (Process)```，每一个进程独享一块特定的内存地址。一个进程同一时间可以拥有多个 ```线程 (Thread)``` 去并行地执行不同的 ```任务 (Task)```。线程具有以下几个非常重要的特点:
- 它允许一个程序同时完成多个任务
- 线程执行代码的时候是线性执行的
- 由于不同的线程共享同一进程的地址，它们之间可以进行通信
- 每一个线程拥有其独立的 ```状态 (State):``` ```程序计数器 (Program Counter)```，```寄存器 (Registers)```, ```栈 (Stack)```

### 为什么要使用线程？
- #### 并发性 (Concurrency): <br>
    允许一个 **单核 CPU 交替** 执行多个任务，这有时候会给人一种这些任务在同时进行的错觉，但实际上同一时刻一个 CPU 只能处理一个任务。 比如 ```I/O 并发性 (I/O Concurrency)``` 允许我们与其干等一个硬盘数据的读取返回，不如先去执行其他任务，然后等数据成功返回后再继续切换到原始任务，从而更高效地利用 CPU
	
- #### 并行性 (Parallelism): <br>
    并行性和并发性很容易混淆。并行是真正意义上利用 **多个 CPU** 实现在同一时刻并行地完成多个任务
	
- #### 简便性 (Convenience): <br>
    线程的存在允许我们在 ```后台 (Background)``` 执行一些小的短期任务, 比如一个 ```主节点 (Master Node)``` 可以不断地筛查它底下的 ```工人节点们 (Worker)``` 还是否存活

### 如果不能使用线程怎么办？
一种可以取代线程的编程模式叫做 ```事件驱动编程 (Event-driven Programming)```。使用了这一技术的 ```运用程序 (Application)``` 的代码中通常有一个 ```主循环 (Main Loop)``` 用以监听其他```事件 (Event)``` 的发生并触发与之对应的回调函数 (Callback Function)。我个人对这个技术的理解用下面这段伪代码表示:

```Java
// 无限循环去检测 事件1 ~ 事件N 的发生
while (True) {
    switch (event) {
        case "EVENT 1"：
            callback1();
            break;
        case "EVENT 2"：
            callback1();
            break;
	    
        ...
        ...
		
        case "EVENT N"：
            callbackN();
            break;
        default:
            // Do something
    }
}
```

换言之，就是用一个不断在跑的循环去检测不同事件的发生，一旦某一个事件发生了，执行对应的一段函数，然后回到循环开始的位置，继续检测其他事件的发生，从而模拟出拥有线程的效果。这一技术可以帮助实现前面提到的 I/O 并行，并且减少了创建和管理线程的开支。但它也有缺点，并且这些缺点使得这个技术没有那么流行

#### 事件驱动编程的缺点
- 最明显的缺点就是，相比较线程来说，不太好写代码 (当然这个也因人而异)
- 无法利用多核 CPU 进行加速 (有些资料也说是可以的，但是需要进行很多线程之间的额外协调，而这一过程很繁琐)

<!--------------------------------------------------------------------------------------------------->

### 使用线程时可能面临的挑战
- #### 共享数据 (Shared Data): <br>
    由于不同的线程共享同一片内存，这会导致一些潜在的问题。比如如果有两个线程 A 和 B 同时想要执行 ```n = n + 1```这个语句 (假设 n 的初始值为 0)。那么如果 A 正在读取 n 时 B 刚刚将 n 的值 + 1 (这个时候 A 读取的是还是旧值 0), 这就会导致当两个线程都执行完改语句后 n 的值为 1 而不是 2。去解决这一问题，我们通常使用 ```加锁 (Go 里面的 sync.Mutex)``` 或者干脆直接避免同享 ```可变性数据 (Mutable Data)```
	
- #### 线程间的协同 (Coordination Between Threads): <br>
    当线程 A 正在产生数据，而另外一个线程 B 正在消耗该数据的时候，B 是如何等待 A 的，并且 B 在决定等待的时候是如何释放 CPU 自愿的？而 A 后面又该如何唤醒 B？
	
- #### 死锁 (Deadlock): <br>
    当线程 A 在等待线程 B 而线程 B 也在等待线程 A 的时候，就会出现两者 ```相互等待``` 的尴尬局面，这也被称之为 ```死锁```，即两方谁也不动，相互锁死
  
    
    
    
